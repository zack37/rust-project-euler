#[derive(Debug)]
struct ProductResult<'a> {
    sequence: &'a Vec<u64>,
    product: u64,
}

impl<'a> ProductResult<'a> {
    fn new(sequence: &Vec<u64>) -> ProductResult {
        ProductResult { sequence: sequence, product: sequence.iter().fold(1, |acc, cur| acc * cur) }
    }
}

fn main() {
    let sample = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452874930358907296290491560440772390713810515859307960866701724271218839987979087922749219016997208880937766572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224137565705605749026140797296865241455100474821663704844031998900088952434506585412275886668811642717147992444292823086346567481391912316282458617866458359124566529476545682848912883142607690042242190226710556263211111093705442175069416589604080719840385096245544436298123098787992724428490918884580156166097919133875499200524063689925607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
    
    let list: Vec<u64> = sample.split("").filter(|&x| x != "").map(|x| x.parse::<u64>().unwrap()).collect();
    let windows = windowed(&list, 4);
    let result: ProductResult = windows.iter()
        .map(|ref x| ProductResult::new(&x))
        .max_by(|ref x| x.product).unwrap();
    println!("Result: {:?}", result.sequence);
        //.map(|&x| x.iter().map(|y| .unwrap() ));
    //println!("Windowed: {:?}", windowed(&list, 5));
}

fn windowed(source: &Vec<u64>, window_size: usize) -> Vec<Vec<u64>> {
    source.iter()
        .enumerate()
        .map(|(i, _)| source.iter().skip(i).take(window_size).map(|&x| x).collect())
        .filter(|ref x: &Vec<u64>| x.len() == window_size)        
        .collect()
}